#!/usr/bin/perl
# Unitemare
# This script reads Sequest outfiles and writes them to the new combined output format
# Copyright 2002 Johannes Graumann, California Institute of Technology
# Contact: graumann@its.caltech.edu
#
# use diagnostics;
$version = 1.6;
$date = "08/08/2002";

print ">\n> This is Unitemare, Version $version $date.\n> Copyright 2002 Johannes Graumann, California Institute of Technology\n>\n";

# Is a target directory given for the *.sqt files?
my $killbit = 0; 
if (exists ($ARGV[0])) {
	$ARGV = "@ARGV";
	# if '--help' option given ...
		if ($ARGV =~ /--help/i) {
			print ">  The script parses Sequest output and creates files in Sequestu output format from it.\n";
			print ">  It has to be evoced in the parent directory of a Sequest output tree.\n";
			print ">  The script derives the directories to descent into/sqt-files to create from the names of\n";
			print ">  *.dat files present - 'touch <dir_name>.dat' might be necessary.\n>\n";
			print ">  Accepted options are:\n>\t-t <dir>\tDirectory the '*.sqt' files are written to (default: '.')\n>\t-ko\t\toutfiles are unlinked upon parsing (kill out)\n>\n";
			exit;
		}
	# if target directory is given as "-t xyz/" ...
		if ($ARGV =~ /-t\s+([\w\d\-\/\$.]+)\/\s*/) {
			$targetdir = $1;
		}
	# if target directory is given as "-t xyz" ...
		if ($ARGV =~ /-t\s+([\w\d\-\/\$.]+)\s*/) {
			$targetdir = $1;
		}
		if ($ARGV !~ /-t\s+/) {
			$targetdir = ".";
		}
	# Do you want to discard *.out files after readout?
		if ($ARGV =~ /-ko\s*/) {
			++$killbit;
		}
}
else {
	$targetdir =".";
}
# Are there any *.dat file that might have spawned Xtracted directorys?
unless (-e <*.dat>) {
	print ">  No *.dat file in this directory!\n>  Get me something to work with!\n>\n";
	exit;
}
# Does the target directory exist?
unless (-e $targetdir) {
	print ">  The target directory given does not exist!\n>\tI would appreciate if you think before using me!\n";
	exit;
}	
print ">  Will write created *.sqt files to $targetdir!\n";
 
# Deduct directory names from *.dat files
foreach $originfile (<*.dat>) {
	print ">  Found $originfile!\n>\tWill try to work on the respective Xtract directory ...\n";
	chomp ($originfile);
	$originfile =~ /([\w\d.-]+).dat/;
	$origin = $1;
	$target = "$targetdir/$origin",
	open (SQTFILE,">$target.sqt") or die "Can't create or write to $target.sqt: $!\n";
# descent into the respective directorys
	chdir $origin or die ">\tNo Xtract directory for $origin.dat!\n";
# grab header information from first *.out file in directory ...
	print ">\tSucking header information from the first *.out ...\n";
	open (HEADERSOURCE,"find . -name \"*.out\" -print| head -1 |");
	$headersource = <HEADERSOURCE>;
	close (HEADERSOURCE);
	chomp ($headersource);
	open (HEADERSOURCE,"$headersource") or die "Can't open $headersource: $!\n";
	my $emptylinecount = 0;
	LOOP: while ($line = <HEADERSOURCE>) {
		if ($emptylinecount > 1) {
			last LOOP;
		}
		else {
			if ($line !~ /[\d\w]/) {
				++$emptylinecount;
			}
			chomp ($line);
			$line =~ s/^[\s]*//;
			push (@header, $line);
			next LOOP;
		}
	} 
	close (HEADERSOURCE);
# write header information to *.sqt ...
	print SQTFILE " SEQUEST-PVM v.27 (rev. 6), (c) 1993\n";
	for $c (3 .. $#header) {
		print SQTFILE " $header[$c]\n";
	}
	@header = ();
# robust way of dealing with tns of files: now convenient globbing but filelist to be read ...
	print ">\tCreating *.out file list by system call ...\n";
	system ("find . -name \"*.out\" -print > Unitemare.filelist");
	open (LIST,"Unitemare.filelist") or die "Can't open $origin/Unitemare.filelist: $!\n";
# open any *.out file in list and parse *.sqt info
	print ">\tLet's have those tasty *.out files now ...\n";
	LOOPONE: foreach $file (<LIST>) {
		open (OUTFILE,$file) or die "Can't open $file: $!\n";
		$linecb = 0;
		while ($line = <OUTFILE>) {
			if ($line =~ /\w*.(\d*).(\d*).([123]).out/) {
				$startspec = $1; # !
				$stopspec = $2; # !
				$chargestate = $3; # !
			}
			elsif ($line =~ /\d{2}\/\d{2}\/\d{4}/) {
				@split = split (/.\s+on\s+/,$line);
				chomp (@split);
					@splittwo = split (/\./,$split[1]);
					chomp (@splittwo);
					$slave = $splittwo[0]; #!

					@splittwo = split (/\,\s/,$split[0]);
					chomp (@splittwo);
					if ($splittwo[2] =~ /(\d+)\s+min.\s+(\d+)/) {
						$min = $1;
						chomp ($min);
						$sec = $2;
						chomp ($sec);
						$duration = $min * 60 + $sec;
					}
					elsif ($splittwo[2] =~ /(\d+)\s+min?/) {
						$min = $1;
						chomp ($min);
						$duration = $min * 60;
					}
					else{
						@splitthree = split (/\s/,$splittwo[2]);
						chomp (@splitthree);
	 					$duration = $splitthree[0];# !
					}
	 		}
			elsif ($line =~ /\=\s(\d*.\d*)\s\~/) {
				$parentmass = $1;
		 	}
			elsif ($line =~ /(\d*.\d*),\slowest\sSp\s\=\s(\d*.\d*),\s\#\smatched\speptides\s\=\s(\d*)/) {
				$peakinten = $1;
				$lowestsp = $2;
	 			$pepmatch = $3;
				print SQTFILE "S\t$startspec\t$stopspec\t$chargestate\t$duration\t$slave\t$parentmass\t$peakinten\t$lowestsp\t$pepmatch\n";
	 		}
			# Mode switch after reaching the peptide listing:
			elsif ($line =~ /\s*---{3}\s*/) {
				$linecb = $linecb + 1;
			}
			elsif ($linecb > 0) {
				# Quit at first empty line!
				unless ($line =~ /[\w\d-]+/) {
					close (OUTFILE);
					if ($killbit == 1) {
						unlink ($file);
					}
					$linecb = 0;
					next LOOPONE;
				} 
				# Peptide entry found!
				if ($line =~ /^\s*\d*.\s*(\d*)\s*\/\s*(\d*)\s*(\d*.\d*)\s*(\d*.\d*)\s*(\d*.\d*)\s*(\d*.\d)\s*(\d*)\s*\/\s*(\d*)\s*([\S]*)[\s\d+]*([\w-].[\S]*.[\w-])/) {
					print SQTFILE "M\t$1\t$2\t$3\t$4\t$5\t$6\t$7\t$8\t$10\tU\nL\t$9\n";
				}
				# Peptide in multiple ORFs:
				elsif ($line =~ /^\s*([\S]+)\s*/) {
					print SQTFILE "L\t$1\n";
				}
			}
		}
	}
# kill the file list and klimb up to parent level ...
	close (LIST);
	unlink ("Unitemare.filelist");
	$chdir = "..";
	chdir $chdir;
#	if ($killbit == 1) {
#		rmdir ($origin);
#	}
}
close (SQTFILE);

# Check for pta directory, read in *.out and files and append them to the appropriate *.sqt
print ">  Looking into the pta directory ...\n";
unless (-e <pta/*.out>) {
	print ">  This parent directory doesn't contain a pta directory\n>  or there are no *.out files in the pta directory!\n";
	print ">\n>  Unitemare finished successfully! I go to sleep now!\n";
	exit;
}
open (PHSFILE,">phs.sqt") or die "Can't open phs.sqt: $!\n";
# grab header information from first *.out file in directory ...
	print ">\tSucking header information from the first *.out ...\n";
	open (HEADERSOURCE,"find pta -name \"*.out\" -print| head -1 |");
	$headersource = <HEADERSOURCE>;
	close (HEADERSOURCE);
	chomp ($headersource);
	open (HEADERSOURCE,"$headersource") or die "Can't open $headersource: $!\n";
	my $emptylinecount = 0;
	LOOP: while ($line = <HEADERSOURCE>) {
		if ($emptylinecount > 1) {
			last LOOP;
		}
		else {
			if ($line !~ /[\d\w]/) {
				++$emptylinecount;
			}
			chomp ($line);
			$line =~ s/^[\s]*//;
			push (@header, $line);
			next LOOP;
		}
	} 
	close (HEADERSOURCE);
# write header information to *.sqt ...
	print PHSFILE "SEQUEST-PVM v.27 (rev. 6), (c) 1993\n";
	for $c (3 .. $#header) {
		print PHSFILE "$header[$c]\n";
	}
	@header = ();
# robust way of dealing with tns of files: now convenient globbing but filelist to be read ...
	print ">\tCreating *.out file list by system call ...\n";
	system ("find pta -name \"*.out\" -print > Unitemare.filelist");
	open (LIST,"Unitemare.filelist") or die "Can't open $origin/Unitemare.filelist: $!\n";
	print ">\tLet's have those tasty *.out files now ...\n";
LOOPTWO: foreach $file (<LIST>) {
	@split = split (/\./,$file);
		chomp (@split);
		@splittwo = split (/\//,$split[0]);
	open (OUTFILE,"$file") or die "Can't open $file: $!\n";
	$linecb = 0;
	while ($line = <OUTFILE>) {
		if ($line =~ /\w*.(\d*).(\d*).([123]).out/) {
			$startspec = $1; # !
			$stopspec = $2; # !
			$chargestate = $3; # !
		}
		elsif ($line =~ /\d{2}\/\d{2}\/\d{4}/) {
			@split = split (/.\s+on\s+/,$line);
			chomp (@split);
				@splittwo = split (/\./,$split[1]);
				chomp (@splittwo);
				$slave = $splittwo[0]; #!

				@splittwo = split (/\,\s/,$split[0]);
				chomp (@splittwo);
				if ($splittwo[2] =~ /(\d+)\s+min.\s+(\d+)/) {
					$min = $1;
					chomp ($min);
					$sec = $2;
					chomp ($sec);
					$duration = $min * 60 + $sec;
				}
				elsif ($splittwo[2] =~ /(\d+)\s+min?/) {
					$min = $1;
					chomp ($min);
					$duration = $min * 60;
				}
				else{
					@splitthree = split (/\s/,$splittwo[2]);
					chomp (@splitthree);
					$duration = $splitthree[0];# !
				}
		}
 		elsif ($line =~ /\=\s(\d*.\d*)\s\~/) {
 			$parentmass = $1;
	 	}
 		elsif ($line =~ /(\d*.\d*),\slowest\sSp\s\=\s(\d*.\d*),\s\#\smatched\speptides\s\=\s(\d*)/) {
 			$peakinten = $1;
 			$lowestsp = $2;
			$pepmatch = $3;
			print PHSFILE "S\t$startspec\t$stopspec\t$chargestate\t$duration\t$slave\t$parentmass\t$peakinten\t$lowestsp\t$pepmatch\n";
		}
		# Mode switch after reaching the peptide listing:
		elsif ($line =~ /\s*---{3}\s*/) {
			$linecb = $linecb + 1;
		}
		elsif ($linecb > 0) {
			# Quit at first empty line!
			unless ($line =~ /[\w\d-]+/) {
				close (OUTFILE);
				if ($killbit == 1) {
					unlink ($file);
				}
				$linecb = 0;
				next LOOPTWO;
			} 
			# Peptide entry found!
			if ($line =~ /^\s*\d*.\s*(\d*)\s*\/\s*(\d*)\s*(\d*.\d*)\s*(\d*.\d*)\s*(\d*.\d*)\s*(\d*.\d)\s*(\d*)\s*\/\s*(\d*)\s*([\S]*)[\s\d+]*([\w-].[\S]*.[\w-])/) {
				print PHSFILE "M\t$1\t$2\t$3\t$4\t$5\t$6\t$7\t$8\t$10\tU\nL\t$9\n";
			}
			# Peptide in multiple ORFs:
			elsif ($line =~ /^\s*([\S]+)\s*/) {
				print PHSFILE "L\t$1\n";
			}
		}
	}
}
close (LIST);
close (PHSFILE);
unlink ("Unitemare.filelist");
#if ($killbit == 1) {
#	rmdir ("pta");
#}

print ">\n>  Unitemare finished successfully! I go to sleep now!\n>\n";
exit;
#
# Version 1.6, 08/08/2002
#	- turned out that GPLing was illegal --> removed it;
#
# Version 1.5, 07/03/2002
#	- GPLed;
#	- changes to '--help' statement;
#	- pseudo-header lines now started by <space> - as in sequestu output;
# Version 1.4, 06/19/2002
#	- copyright presented upon run;
#	- added blank line to completion message;
#	- added proper '--help' message;
# Version 1.3, 05/20/2002
#	- properly copyrighted;
# Version 1.2, 02/26/2002:
#	- *.out files in pta directory are now channeled into phs.sqt - as the sequestu-setup would handle it;
# Version 1.1, 02/21/2002:
#	This version is dedicated to Laurence Florens de Provence!
#	- file globbing way more robust now: read into list by "find" and than accessed by call from list;
# Version 1.0, 02/20/2002:
#	- header information is now pulled from the first *.out in an extract directory - Show needs dbase and DifMod info;
# Version 0.9, 02/19/2002:
#	- Unitemare now complains if lacking rights to create/write to *.sqt file - Thanks Mike!
# Version 0.8, 02/14/2002:
#	- adding -ko option ("knock out" or "kill *.out"): deletes *.out files after read out and removes the directorys after leaving;
# Version 0.7, 02/04/2002:
#	- locus IDing also fixed for non-Xcorr line locus IDs (Joh, you moron!);
#	- Soothing finish line included (requested by master-baby sitter Dave);
# Version 0.6, 02/04/2002:
#	- locus IDing corrected: all non-white spaces now supported;
#	  replaced "([\d\w-]*)" with "([\S]*)";
# Version 0.5, 02/04/2002 - first release:
#	- Removed "./" requirement in recognition of first *.out file line (file name), since phospho Sequest doesn't produce it (sigh!);
#         Regex reads now "/\w*.(\d*).(\d*).([123]).out/" instead of "/.\/\w*.(\d*).(\d*).([123]).out/";
# Version 0.4, 01/26/2002:
#	- High fins ("-") are now recognized in directory names;
#	- High fins ("-") are now properly handeled when part of locus name;
#	- To realize the first two points, mode switch after reaching the peptide listing was shifted to the "---" line in the *.out file;
#	- Unitemare will now exit if option doesn't follow the 'Unitemare -t target_directory' synthax;
#	- Random bits of comment added;
# Version 0.3, 01/25/2002:
#	- Fixed $duration parsing; now correctly extracting "xy min.", "xy sec." and "wx min. yz sec.";
#	- Implemented readout of *.out files in pta directory; results are appended to the *.sqt file the *.out belongs to;
# Version 0.2:
#	Long live the naughty bug-checker El Davido Tabb!
#	- Print fake .sqt-SEQUEST .sqt-file header to the beginning of any created .sqt file;
#	- "M" line terminating "U" now printed;
#	- Fixed (removed) wrong output at "M" line start;
#	- Fixed bug by peptide sequence parsing ("#", "$" and "*" now accepted);
#	- Command line announces now speciffically which *.dat was found;
#	- Added support for target directory given in the command line as "-t xyz";
#	- When peptide matches multiple ORFs, additional ORF descriptions are only given as the stretch to the first "\s";
#	- If $duration exceeds 59 sec, the proper time in seconds is now calculated and given out in the "S" line;
#	- Fixed problem in peptide sequence output that was caused by "-" containing locus names;
#	- Fixed bug in output of predicted/observed ions caused by "\s" inconsistencys;
